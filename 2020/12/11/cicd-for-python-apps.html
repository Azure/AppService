<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.5 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Using GitHub Actions for Python Applications - Azure App Service</title>
<meta name="description" content="GitHub announced CI/CD support through GitHub Actions which became generally available at GitHub Universe in November 2019. Since then, many Azure services have released actions and integrations to make developers’ workflows more efficient. The App Service Deployment Center guides developers to set up GitHub Actions to deploy their web apps. Since then, our teams have received requests for guidance and best practices when setting up CI/CD (Continuous Integration and Delivery) for deploying Python apps to App Service.  This article assumes you are familiar with CI/CD pipelines. If you are not familiar, read this article for an overview.Building and deploying Python appsA simple CI pipeline for a Python application might have three steps: pip install the packages, run tests, and send the application to the server. This seems like a sound approach… right? That pattern might work for simple applications, but if the application uses packages that rely on the Operating System (such as database drivers, scipy, or scikit-learn), you may run into problems once the application starts on the server. This is because Python will make absolute references to the OS libraries, and if there are any differences between the libraries installed on the CI machine and the server, then the application will not run correctly.This may seem like an excellent opportunity to leverage Docker. With Docker, you can build a container image with the Python application’s dependencies already installed. From there, you ship the image to a host with Docker installed and “just run it”. However, this option is not without its drawbacks. You will need to manage a container registry and configure your network such that the CI and production servers can securely access it. The Dockerfile also becomes part of the application repository, so you or your team will be responsible for updating the base OS and configuring the container. Fun fact: Docker was publicly announced at PyCon in 2013Nylas wrote an excellent article on this topic last year. Their article covers even more deployment technologies for Python applications. Check their article to learn about your other options. Now let’s learn more about deploying Python applications to App Service without managing Docker images.Deploying to App ServiceFor those not familiar with Azure App Service, it is a platform-as-a-service (PaaS) for hosting web and API applications. You can deploy your application code or a container image. The service has managed runtimes for Python, .NET, Node, Java, PHP, and Ruby. This gives developers the choice to use containers or to simply deploy their code and let the service manage the runtime for them.If you are setting up a CI/CD pipeline for your Python apps to App Service without using containers, you cannot simply pip install and deploy your app and packages to App Service (or any server) because the OS on your build server will most likely not match the runtime on Azure. To address this, simply create an app setting on your App Service named SCM_DO_BUILD_DURING_DEPLOYMENT with a value of true. This app setting will trigger the Oryx build pipeline to re-install your packages during deployment. Oryx is an open-source utility by Microsoft that automatically builds source code. Oryx runs in your web app’s SCM (site control manager) site. By setting this app setting, Oryx will pip install your dependencies on the runtime image so that the packages can take the appropriate dependencies on the OS libraries.ExamplesThe sections below show example GitHub Actions workflows for building and deploying Python apps to App Service. Although the samples use GitHub Actions, you can use the same pattern on other CI/CD providers such as Azure DevOps or Jenkins.PrerequisitesBefore following the examples below, make sure you have done the following.  Create a Python web app on Azure. Follow this quickstart to create a site.  Create an Azure Service Principal. Follow this guide to create a Service Principal. A Service Principal is an identity in Azure Active Directory that is typically used for automation and accessing secrets. You will need to create a Service Principal so the GitHub Actions workflowDjangoSee the example workflow for building and deploying a Django app. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL.The workflow starts by checking out the repository to the build VM, setting up the desired Python version, and creating a virtual environment.- uses: actions/checkout@v2- name: Setup Python version  uses: actions/setup-python@v2  with:  python-version: 3.8- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activateOnce the virtual environment is activated, the dependencies are installed from the requirements.txt file. Next, we use manage.py to collect the static assets and run our unit tests.- name: Install dependencies  run: pip install -r requirements.txt- name: Collect static  run: python manage.py collectstatic- name: Run tests  run: python manage.py testAssuming all those previous steps succeed, the files are uploaded for the next job. The virtual environment is not uploaded since it is not compatible with the runtime OS. A nice side-effect of uploading the files at the end of the job is that you can download the files from the Actions tab to debug or inspect the contents if a deployment fails.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !venv/The second job begins by downloading the files we uploaded in the previous job, then logs into the Azure CLI using a Service Principal that you set as a secret earlier.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}Once the Azure CLI is authenticated, the job sets the SCM_DO_BUILD_DURING_DEPLOYMENT setting mentioned earlier. It also sets app settings to disable static collection (since that was done in the previous job), to run migrations on the database, and to set the Django environment to “production”. The POST_BUILD_COMMAND is a hook where you can execute commands following the runtime build. In this case, we’re running manage.py makemigrations &amp;&amp; python migrate. You could apply database migrations as part of the CI workflow, but you would need to set the connection string as a secret, and if you have networking rules securing your database you will need to make the database accessible from the CI pipeline. In this case, migration will be applied from the Django app on App Service, so this assumes you have set the database credentials on the web app.Finally, the job deploys the code using the webapps-deploy action.- name: Disable static collection and set migration command on App Service  uses: Azure/appservice-settings@v1  with:      app-name: ${{ env.WEBAPP_NAME }}    app-settings-json: &#39;[{ &quot;name&quot;: &quot;DISABLE_COLLECTSTATIC&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;POST_BUILD_COMMAND&quot;,  &quot;value&quot;: &quot;python manage.py makemigrations &amp;&amp; python manage.py migrate&quot; }, { &quot;name&quot;: &quot;SCM_DO_BUILD_DURING_DEPLOYMENT&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;DJANGO_ENV&quot;, &quot;value&quot;: &quot;production&quot;}]&#39;- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}  By default, the appservice-settings action will mask the inputs and obfuscate any occurences of those strings in logs. Set mask-inputs: false to disable this.Flask and Vue.jsSee the example workflow for building and deploying a Flask app with Vue.js. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL. You also need to replace the placeholder value for the RESOURCE_GROUP environment variable at the top of the workflow file.This workflow begins similarly to the Django example by setting the Python version, creating a virtual environment, and installing the Python packages. Unique to this example, it also sets Node.js to the desired version since the job will need to install the Vue project’s dependencies and build it.- uses: actions/checkout@v2- name: Set up Python  uses: actions/setup-python@v2  with:    python-version: 3.6- name: Set up Node.js  uses: actions/setup-node@v1  with:    node-version: 12- name: Install and build Vue.js project  run: |    npm install    npm run build- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activate- name: Install dependencies  run: pip install -r requirements.txt- name: test with PyTest  run: pytest --cov=app --cov-report=xmlOnce the Flask and Vue.js apps are built and tested the files are uploaded for the second job… except for the node_modules/ and venv/ directories. We want to exclude these directories and allow Oryx to install the dependencies on the runtime image like in the Django example.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !node_modules/      !venv/The second job downloads the artifact, logs into the Azure CLI, and sets the SCM_DO_BUILD_DURING_DEPLOYMENT flag and FLASK_ENV to “production”. Unlike the Django example, the workflow sets the “startup-file” command to gunicorn --bind=0.0.0.0 --timeout 600 app:app. (Gunicorn is a WSGI HTTP Server commonly used for Python applications. Learn more about custom startup commands on App Service.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}- name: Configure deployment and runtime settings on the webapp  run: |    az configure --defaults ${{ env.RESOURCE_GROUP }}    az webapp config appsettings --name ${{ env.WEBAPP_NAME }} --settings \        SCM_DO_BUILD_DURING_DEPLOYMENT=true \        FLASK_ENV=production    az webapp config set --name ${{ env.WEBAPP_NAME }} \        --startup-file &quot;gunicorn --bind=0.0.0.0 --timeout 600 app:app&quot;Finally, the application is deployed with the webapps-deploy action.- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Azure App Service">
<meta property="og:title" content="Using GitHub Actions for Python Applications">
<meta property="og:url" content="https://azure.github.io/AppService/2020/12/11/cicd-for-python-apps.html">


  <meta property="og:description" content="GitHub announced CI/CD support through GitHub Actions which became generally available at GitHub Universe in November 2019. Since then, many Azure services have released actions and integrations to make developers’ workflows more efficient. The App Service Deployment Center guides developers to set up GitHub Actions to deploy their web apps. Since then, our teams have received requests for guidance and best practices when setting up CI/CD (Continuous Integration and Delivery) for deploying Python apps to App Service.  This article assumes you are familiar with CI/CD pipelines. If you are not familiar, read this article for an overview.Building and deploying Python appsA simple CI pipeline for a Python application might have three steps: pip install the packages, run tests, and send the application to the server. This seems like a sound approach… right? That pattern might work for simple applications, but if the application uses packages that rely on the Operating System (such as database drivers, scipy, or scikit-learn), you may run into problems once the application starts on the server. This is because Python will make absolute references to the OS libraries, and if there are any differences between the libraries installed on the CI machine and the server, then the application will not run correctly.This may seem like an excellent opportunity to leverage Docker. With Docker, you can build a container image with the Python application’s dependencies already installed. From there, you ship the image to a host with Docker installed and “just run it”. However, this option is not without its drawbacks. You will need to manage a container registry and configure your network such that the CI and production servers can securely access it. The Dockerfile also becomes part of the application repository, so you or your team will be responsible for updating the base OS and configuring the container. Fun fact: Docker was publicly announced at PyCon in 2013Nylas wrote an excellent article on this topic last year. Their article covers even more deployment technologies for Python applications. Check their article to learn about your other options. Now let’s learn more about deploying Python applications to App Service without managing Docker images.Deploying to App ServiceFor those not familiar with Azure App Service, it is a platform-as-a-service (PaaS) for hosting web and API applications. You can deploy your application code or a container image. The service has managed runtimes for Python, .NET, Node, Java, PHP, and Ruby. This gives developers the choice to use containers or to simply deploy their code and let the service manage the runtime for them.If you are setting up a CI/CD pipeline for your Python apps to App Service without using containers, you cannot simply pip install and deploy your app and packages to App Service (or any server) because the OS on your build server will most likely not match the runtime on Azure. To address this, simply create an app setting on your App Service named SCM_DO_BUILD_DURING_DEPLOYMENT with a value of true. This app setting will trigger the Oryx build pipeline to re-install your packages during deployment. Oryx is an open-source utility by Microsoft that automatically builds source code. Oryx runs in your web app’s SCM (site control manager) site. By setting this app setting, Oryx will pip install your dependencies on the runtime image so that the packages can take the appropriate dependencies on the OS libraries.ExamplesThe sections below show example GitHub Actions workflows for building and deploying Python apps to App Service. Although the samples use GitHub Actions, you can use the same pattern on other CI/CD providers such as Azure DevOps or Jenkins.PrerequisitesBefore following the examples below, make sure you have done the following.  Create a Python web app on Azure. Follow this quickstart to create a site.  Create an Azure Service Principal. Follow this guide to create a Service Principal. A Service Principal is an identity in Azure Active Directory that is typically used for automation and accessing secrets. You will need to create a Service Principal so the GitHub Actions workflowDjangoSee the example workflow for building and deploying a Django app. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL.The workflow starts by checking out the repository to the build VM, setting up the desired Python version, and creating a virtual environment.- uses: actions/checkout@v2- name: Setup Python version  uses: actions/setup-python@v2  with:  python-version: 3.8- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activateOnce the virtual environment is activated, the dependencies are installed from the requirements.txt file. Next, we use manage.py to collect the static assets and run our unit tests.- name: Install dependencies  run: pip install -r requirements.txt- name: Collect static  run: python manage.py collectstatic- name: Run tests  run: python manage.py testAssuming all those previous steps succeed, the files are uploaded for the next job. The virtual environment is not uploaded since it is not compatible with the runtime OS. A nice side-effect of uploading the files at the end of the job is that you can download the files from the Actions tab to debug or inspect the contents if a deployment fails.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !venv/The second job begins by downloading the files we uploaded in the previous job, then logs into the Azure CLI using a Service Principal that you set as a secret earlier.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}Once the Azure CLI is authenticated, the job sets the SCM_DO_BUILD_DURING_DEPLOYMENT setting mentioned earlier. It also sets app settings to disable static collection (since that was done in the previous job), to run migrations on the database, and to set the Django environment to “production”. The POST_BUILD_COMMAND is a hook where you can execute commands following the runtime build. In this case, we’re running manage.py makemigrations &amp;&amp; python migrate. You could apply database migrations as part of the CI workflow, but you would need to set the connection string as a secret, and if you have networking rules securing your database you will need to make the database accessible from the CI pipeline. In this case, migration will be applied from the Django app on App Service, so this assumes you have set the database credentials on the web app.Finally, the job deploys the code using the webapps-deploy action.- name: Disable static collection and set migration command on App Service  uses: Azure/appservice-settings@v1  with:      app-name: ${{ env.WEBAPP_NAME }}    app-settings-json: &#39;[{ &quot;name&quot;: &quot;DISABLE_COLLECTSTATIC&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;POST_BUILD_COMMAND&quot;,  &quot;value&quot;: &quot;python manage.py makemigrations &amp;&amp; python manage.py migrate&quot; }, { &quot;name&quot;: &quot;SCM_DO_BUILD_DURING_DEPLOYMENT&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;DJANGO_ENV&quot;, &quot;value&quot;: &quot;production&quot;}]&#39;- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}  By default, the appservice-settings action will mask the inputs and obfuscate any occurences of those strings in logs. Set mask-inputs: false to disable this.Flask and Vue.jsSee the example workflow for building and deploying a Flask app with Vue.js. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL. You also need to replace the placeholder value for the RESOURCE_GROUP environment variable at the top of the workflow file.This workflow begins similarly to the Django example by setting the Python version, creating a virtual environment, and installing the Python packages. Unique to this example, it also sets Node.js to the desired version since the job will need to install the Vue project’s dependencies and build it.- uses: actions/checkout@v2- name: Set up Python  uses: actions/setup-python@v2  with:    python-version: 3.6- name: Set up Node.js  uses: actions/setup-node@v1  with:    node-version: 12- name: Install and build Vue.js project  run: |    npm install    npm run build- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activate- name: Install dependencies  run: pip install -r requirements.txt- name: test with PyTest  run: pytest --cov=app --cov-report=xmlOnce the Flask and Vue.js apps are built and tested the files are uploaded for the second job… except for the node_modules/ and venv/ directories. We want to exclude these directories and allow Oryx to install the dependencies on the runtime image like in the Django example.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !node_modules/      !venv/The second job downloads the artifact, logs into the Azure CLI, and sets the SCM_DO_BUILD_DURING_DEPLOYMENT flag and FLASK_ENV to “production”. Unlike the Django example, the workflow sets the “startup-file” command to gunicorn --bind=0.0.0.0 --timeout 600 app:app. (Gunicorn is a WSGI HTTP Server commonly used for Python applications. Learn more about custom startup commands on App Service.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}- name: Configure deployment and runtime settings on the webapp  run: |    az configure --defaults ${{ env.RESOURCE_GROUP }}    az webapp config appsettings --name ${{ env.WEBAPP_NAME }} --settings \        SCM_DO_BUILD_DURING_DEPLOYMENT=true \        FLASK_ENV=production    az webapp config set --name ${{ env.WEBAPP_NAME }} \        --startup-file &quot;gunicorn --bind=0.0.0.0 --timeout 600 app:app&quot;Finally, the application is deployed with the webapps-deploy action.- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}">



  <meta property="og:image" content="https://azure.github.io/AppService/assets/images/icon.png">





  <meta property="article:published_time" content="2020-12-11T00:00:00+00:00">





  

  


<link rel="canonical" href="https://azure.github.io/AppService/2020/12/11/cicd-for-python-apps.html">





  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "url": "https://azure.github.io/AppService",
      "logo": "https://azure.github.io/AppService/assets/images/icon.png"
    }
  </script>



  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "name": "Azure App Service",
      "url": "https://azure.github.io/AppService",
      "sameAs": null
    }
  </script>







<!-- end _includes/seo.html -->


<link href="/AppService/feed.xml" type="application/atom+xml" rel="alternate" title="Azure App Service Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/AppService/assets/css/main.css">

<!--[if IE ]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->

<!-- Jekyll env: production -->



    <!-- insert favicons. use https://realfavicongenerator.net/ -->
<link rel="icon" 
      type="image/png" 
      href="/AppService/media/pages/new_app_service_logo_16.png">
<link rel="shortcut icon" 
      type="image/png" 
      href="/AppService/media/pages/new_app_service_logo_16.png">

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/AppService/"><img src="/AppService/media/pages/new_app_service_logo_64.svg" alt=""></a>
        
        <a class="site-title" href="/AppService/">
          Azure App Service
          <span class="site-subtitle">Team Blog</span>
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/AppService/tags/" >Tags</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  
  
    
      
      
      
      
    
    
      

<nav class="nav__list">
  
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle menu</label>
  <ul class="nav__items">
    
      <li>
        
          
          

          <a href="/AppService/"><span class="nav__sub-title">Home</span></a>
        

        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Product Areas</span>
        

        
        <ul>
          
            
            

            
            

            <li>
              <a href="/AppService/networking/" class="">Networking & ASE</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/java/" class="">Java</a>
              
                
                
                
                
    
                
                
                <ul>
                  <li style="padding-left: 6px;"><a href="/AppService/java/videos/" class="">Videos</a></li>
                </ul>
                
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/diagnostics/" class="">Diagnostics</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/certsdomains/" class="">Certs and Domains</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/deployment/" class="">Deployment, CI/CD, Slots</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/windows-containers/" class="">Windows Containers</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/sidecars/" class="">Sidecars</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/ai-integration/" class="">AI Integration</a>
              
            </li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Reference</span>
        

        
        <ul>
          
            
            

            
            

            <li>
              <a href="https://docs.microsoft.com/azure/app-service/" class="">Documentation</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="https://github.com/Azure/app-service-linux-docs" class="">Linux FAQ</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="https://aka.ms/appservicewindowscontainerwiki" class="">Windows Containers Wiki</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/zero-to-hero/" class="">Zero to Hero tutorials</a>
              
            </li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">More</span>
        

        
        <ul>
          
            
            

            
            

            <li>
              <a href="https://twitter.com/Azure" class="">Twitter</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/feed.xml" class="">RSS Feed</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="https://azure.microsoft.com/blog/" class="">Azure Blog</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="https://azure.microsoft.com/updates/" class="">Azure Updates</a>
              
            </li>
          
        </ul>
        
      </li>
    
      <li>
        
          <span class="nav__sub-title">Archives</span>
        

        
        <ul>
          
            
            

            
            

            <li>
              <a href="/AppService/2020" class="">2020</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/2019" class="">2019</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/2018" class="">2018</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/2017" class="">2017</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/2016" class="">2016</a>
              
            </li>
          
            
            

            
            

            <li>
              <a href="/AppService/posts/" class="">All posts</a>
              
            </li>
          
        </ul>
        
      </li>
    
  </ul>
</nav>
    
  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Using GitHub Actions for Python Applications">
    <meta itemprop="description" content="GitHub announced CI/CD support through GitHub Actions which became generally available at GitHub Universe in November 2019. Since then, many Azure services have released actions and integrations to make developers’ workflows more efficient. The App Service Deployment Center guides developers to set up GitHub Actions to deploy their web apps. Since then, our teams have received requests for guidance and best practices when setting up CI/CD (Continuous Integration and Delivery) for deploying Python apps to App Service.  This article assumes you are familiar with CI/CD pipelines. If you are not familiar, read this article for an overview.Building and deploying Python appsA simple CI pipeline for a Python application might have three steps: pip install the packages, run tests, and send the application to the server. This seems like a sound approach… right? That pattern might work for simple applications, but if the application uses packages that rely on the Operating System (such as database drivers, scipy, or scikit-learn), you may run into problems once the application starts on the server. This is because Python will make absolute references to the OS libraries, and if there are any differences between the libraries installed on the CI machine and the server, then the application will not run correctly.This may seem like an excellent opportunity to leverage Docker. With Docker, you can build a container image with the Python application’s dependencies already installed. From there, you ship the image to a host with Docker installed and “just run it”. However, this option is not without its drawbacks. You will need to manage a container registry and configure your network such that the CI and production servers can securely access it. The Dockerfile also becomes part of the application repository, so you or your team will be responsible for updating the base OS and configuring the container. Fun fact: Docker was publicly announced at PyCon in 2013Nylas wrote an excellent article on this topic last year. Their article covers even more deployment technologies for Python applications. Check their article to learn about your other options. Now let’s learn more about deploying Python applications to App Service without managing Docker images.Deploying to App ServiceFor those not familiar with Azure App Service, it is a platform-as-a-service (PaaS) for hosting web and API applications. You can deploy your application code or a container image. The service has managed runtimes for Python, .NET, Node, Java, PHP, and Ruby. This gives developers the choice to use containers or to simply deploy their code and let the service manage the runtime for them.If you are setting up a CI/CD pipeline for your Python apps to App Service without using containers, you cannot simply pip install and deploy your app and packages to App Service (or any server) because the OS on your build server will most likely not match the runtime on Azure. To address this, simply create an app setting on your App Service named SCM_DO_BUILD_DURING_DEPLOYMENT with a value of true. This app setting will trigger the Oryx build pipeline to re-install your packages during deployment. Oryx is an open-source utility by Microsoft that automatically builds source code. Oryx runs in your web app’s SCM (site control manager) site. By setting this app setting, Oryx will pip install your dependencies on the runtime image so that the packages can take the appropriate dependencies on the OS libraries.ExamplesThe sections below show example GitHub Actions workflows for building and deploying Python apps to App Service. Although the samples use GitHub Actions, you can use the same pattern on other CI/CD providers such as Azure DevOps or Jenkins.PrerequisitesBefore following the examples below, make sure you have done the following.  Create a Python web app on Azure. Follow this quickstart to create a site.  Create an Azure Service Principal. Follow this guide to create a Service Principal. A Service Principal is an identity in Azure Active Directory that is typically used for automation and accessing secrets. You will need to create a Service Principal so the GitHub Actions workflowDjangoSee the example workflow for building and deploying a Django app. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL.The workflow starts by checking out the repository to the build VM, setting up the desired Python version, and creating a virtual environment.- uses: actions/checkout@v2- name: Setup Python version  uses: actions/setup-python@v2  with:  python-version: 3.8- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activateOnce the virtual environment is activated, the dependencies are installed from the requirements.txt file. Next, we use manage.py to collect the static assets and run our unit tests.- name: Install dependencies  run: pip install -r requirements.txt- name: Collect static  run: python manage.py collectstatic- name: Run tests  run: python manage.py testAssuming all those previous steps succeed, the files are uploaded for the next job. The virtual environment is not uploaded since it is not compatible with the runtime OS. A nice side-effect of uploading the files at the end of the job is that you can download the files from the Actions tab to debug or inspect the contents if a deployment fails.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !venv/The second job begins by downloading the files we uploaded in the previous job, then logs into the Azure CLI using a Service Principal that you set as a secret earlier.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}Once the Azure CLI is authenticated, the job sets the SCM_DO_BUILD_DURING_DEPLOYMENT setting mentioned earlier. It also sets app settings to disable static collection (since that was done in the previous job), to run migrations on the database, and to set the Django environment to “production”. The POST_BUILD_COMMAND is a hook where you can execute commands following the runtime build. In this case, we’re running manage.py makemigrations &amp;&amp; python migrate. You could apply database migrations as part of the CI workflow, but you would need to set the connection string as a secret, and if you have networking rules securing your database you will need to make the database accessible from the CI pipeline. In this case, migration will be applied from the Django app on App Service, so this assumes you have set the database credentials on the web app.Finally, the job deploys the code using the webapps-deploy action.- name: Disable static collection and set migration command on App Service  uses: Azure/appservice-settings@v1  with:      app-name: ${{ env.WEBAPP_NAME }}    app-settings-json: &#39;[{ &quot;name&quot;: &quot;DISABLE_COLLECTSTATIC&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;POST_BUILD_COMMAND&quot;,  &quot;value&quot;: &quot;python manage.py makemigrations &amp;&amp; python manage.py migrate&quot; }, { &quot;name&quot;: &quot;SCM_DO_BUILD_DURING_DEPLOYMENT&quot;, &quot;value&quot;: &quot;true&quot; }, { &quot;name&quot;: &quot;DJANGO_ENV&quot;, &quot;value&quot;: &quot;production&quot;}]&#39;- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}  By default, the appservice-settings action will mask the inputs and obfuscate any occurences of those strings in logs. Set mask-inputs: false to disable this.Flask and Vue.jsSee the example workflow for building and deploying a Flask app with Vue.js. Fork this repository and create a secret with the Service Principal. Name the secret AZURE_SERVICE_PRINCIPAL. You also need to replace the placeholder value for the RESOURCE_GROUP environment variable at the top of the workflow file.This workflow begins similarly to the Django example by setting the Python version, creating a virtual environment, and installing the Python packages. Unique to this example, it also sets Node.js to the desired version since the job will need to install the Vue project’s dependencies and build it.- uses: actions/checkout@v2- name: Set up Python  uses: actions/setup-python@v2  with:    python-version: 3.6- name: Set up Node.js  uses: actions/setup-node@v1  with:    node-version: 12- name: Install and build Vue.js project  run: |    npm install    npm run build- name: Create and start virtual environment  run: |    python3 -m venv venv    source venv/bin/activate- name: Install dependencies  run: pip install -r requirements.txt- name: test with PyTest  run: pytest --cov=app --cov-report=xmlOnce the Flask and Vue.js apps are built and tested the files are uploaded for the second job… except for the node_modules/ and venv/ directories. We want to exclude these directories and allow Oryx to install the dependencies on the runtime image like in the Django example.- name: Upload artifact for deployment jobs  uses: actions/upload-artifact@v2  with:    name: python-app    path: |      .       !node_modules/      !venv/The second job downloads the artifact, logs into the Azure CLI, and sets the SCM_DO_BUILD_DURING_DEPLOYMENT flag and FLASK_ENV to “production”. Unlike the Django example, the workflow sets the “startup-file” command to gunicorn --bind=0.0.0.0 --timeout 600 app:app. (Gunicorn is a WSGI HTTP Server commonly used for Python applications. Learn more about custom startup commands on App Service.- uses: actions/download-artifact@v2  with:    name: python-app    path: .- name: Log in to Azure CLI  uses: azure/login@v1  with:    creds: ${{ secrets.AZURE_SERVICE_PRINCIPAL }}- name: Configure deployment and runtime settings on the webapp  run: |    az configure --defaults ${{ env.RESOURCE_GROUP }}    az webapp config appsettings --name ${{ env.WEBAPP_NAME }} --settings \        SCM_DO_BUILD_DURING_DEPLOYMENT=true \        FLASK_ENV=production    az webapp config set --name ${{ env.WEBAPP_NAME }} \        --startup-file &quot;gunicorn --bind=0.0.0.0 --timeout 600 app:app&quot;Finally, the application is deployed with the webapps-deploy action.- name: Deploy to App Service  uses: azure/webapps-deploy@v2  with:    app-name: ${{ env.WEBAPP_NAME}}">
    <meta itemprop="datePublished" content="December 11, 2020">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Using GitHub Actions for Python Applications
</h1>
          <p class="page__meta">
            
              <i class="far fa-clock" aria-hidden="true"></i> 




  7 minute read

            
            
              • By Jason Freeberg
            
            • December 11, 2020
          </p>
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu">
  <li><a href="#building-and-deploying-python-apps">Building and deploying Python apps</a></li>
  <li><a href="#deploying-to-app-service">Deploying to App Service</a></li>
  <li><a href="#examples">Examples</a>
    <ul>
      <li><a href="#prerequisites">Prerequisites</a></li>
      <li><a href="#django">Django</a></li>
      <li><a href="#flask-and-vuejs">Flask and Vue.js</a></li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p>GitHub announced <a href="https://github.blog/2019-08-08-github-actions-now-supports-ci-cd/">CI/CD support</a> through GitHub Actions which became generally available at GitHub Universe in November 2019. Since then, many Azure services have released <a href="https://github.com/azure/actions">actions</a> and integrations to make developers’ workflows more efficient. The App Service Deployment Center guides developers to set up GitHub Actions to deploy their web apps. Since then, our teams have received requests for guidance and best practices when setting up CI/CD (Continuous Integration and Delivery) for deploying Python apps to App Service.</p>

<blockquote>
  <p>This article assumes you are familiar with CI/CD pipelines. If you are not familiar, <a href="https://www.redhat.com/en/topics/devops/what-cicd-pipeline">read this article</a> for an overview.</p>
</blockquote>

<h2 id="building-and-deploying-python-apps">Building and deploying Python apps</h2>

<p>A simple CI pipeline for a Python application might have three steps: <code class="language-plaintext highlighter-rouge">pip install</code> the packages, run tests, and send the application to the server. This seems like a sound approach… <em>right?</em> That pattern might work for simple applications, but if the application uses packages that rely on the Operating System (such as database drivers, scipy, or scikit-learn), you may run into problems once the application starts on the server. This is because Python will make absolute references to the OS libraries, and if there are any differences between the libraries installed on the CI machine and the server, then the application will not run correctly.</p>

<p>This may seem like an excellent opportunity to leverage Docker. With Docker, you can build a container image with the Python application’s dependencies already installed. From there, you ship the image to a host with Docker installed and “just run it”. However, this option is not without its drawbacks. You will need to manage a container registry and configure your network such that the CI and production servers can securely access it. The Dockerfile also becomes part of the application repository, so you or your team will be responsible for updating the base OS and configuring the container. Fun fact: Docker was publicly announced at <a href="https://www.youtube.com/watch?v=wW9CAH9nSLs">PyCon in 2013</a></p>

<p>Nylas wrote an <a href="https://www.nylas.com/blog/packaging-deploying-python/">excellent article</a> on this topic last year. Their article covers even more deployment technologies for Python applications. Check their article to learn about your other options. Now let’s learn more about deploying Python applications to App Service without managing Docker images.</p>

<h2 id="deploying-to-app-service">Deploying to App Service</h2>

<p>For those not familiar with Azure App Service, it is a platform-as-a-service (PaaS) for hosting web and API applications. You can deploy your application code or a container image. The service has managed runtimes for <a href="https://docs.microsoft.com/azure/app-service/quickstart-python">Python</a>, <a href="https://docs.microsoft.com/azure/app-service/quickstart-dotnetcore">.NET</a>, <a href="https://docs.microsoft.com/azure/app-service/quickstart-nodejs">Node</a>, <a href="https://docs.microsoft.com/azure/app-service/quickstart-java">Java</a>, <a href="https://docs.microsoft.com/azure/app-service/quickstart-php">PHP</a>, and <a href="https://docs.microsoft.com/azure/app-service/quickstart-ruby">Ruby</a>. This gives developers the choice to use containers or to simply deploy their code and let the service manage the runtime for them.</p>

<p>If you are setting up a CI/CD pipeline for your Python apps to App Service <em>without</em> using containers, you cannot simply <code class="language-plaintext highlighter-rouge">pip install</code> and deploy your app and packages to App Service (or any server) because the OS on your build server will most likely not match the runtime on Azure. To address this, simply create an <a href="https://docs.microsoft.com/azure/app-service/configure-common#configure-app-settings">app setting</a> on your App Service named <code class="language-plaintext highlighter-rouge">SCM_DO_BUILD_DURING_DEPLOYMENT</code> with a value of <code class="language-plaintext highlighter-rouge">true</code>. This app setting will trigger the Oryx build pipeline to re-install your packages during deployment. <a href="https://github.com/Microsoft/Oryx">Oryx</a> is an open-source utility by Microsoft that automatically builds source code. Oryx runs in your web app’s SCM (site control manager) site. By setting this app setting, Oryx will <code class="language-plaintext highlighter-rouge">pip install</code> your dependencies <strong>on the runtime</strong> image so that the packages can take the appropriate dependencies on the OS libraries.</p>

<h2 id="examples">Examples</h2>

<p>The sections below show example GitHub Actions workflows for building and deploying Python apps to App Service. Although the samples use GitHub Actions, you can use the same pattern on other CI/CD providers such as Azure DevOps or Jenkins.</p>

<h3 id="prerequisites">Prerequisites</h3>

<p>Before following the examples below, make sure you have done the following.</p>

<ol>
  <li>Create a Python web app on Azure. <a href="">Follow this quickstart to create a site</a>.</li>
  <li>Create an Azure Service Principal. <a href="https://github.com/Azure/login#configure-deployment-credentials">Follow this guide to create a Service Principal</a>. A Service Principal is an identity in Azure Active Directory that is typically used for automation and accessing secrets. You will need to create a Service Principal so the GitHub Actions workflow</li>
</ol>

<h3 id="django">Django</h3>

<p>See the <a href="https://github.com/Azure-Samples/djangoapp/blob/master/.github/workflows/build_and_deploy.yaml"><strong>example workflow for building and deploying a Django app</strong></a>. Fork this repository and <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets">create a secret</a> with the Service Principal. Name the secret <code class="language-plaintext highlighter-rouge">AZURE_SERVICE_PRINCIPAL</code>.</p>

<p>The workflow starts by checking out the repository to the build VM, setting up the desired Python version, and creating a virtual environment.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Setup Python version</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-python@v2</span>
  <span class="na">with</span><span class="pi">:</span>
  <span class="na">python-version</span><span class="pi">:</span> <span class="m">3.8</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Create and start virtual environment</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">python3 -m venv venv</span>
    <span class="s">source venv/bin/activate</span>
</code></pre></div></div>

<p>Once the virtual environment is activated, the dependencies are installed from the <code class="language-plaintext highlighter-rouge">requirements.txt</code> file. Next, we use <code class="language-plaintext highlighter-rouge">manage.py</code> to collect the static assets and run our unit tests.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install dependencies</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">pip install -r requirements.txt</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Collect static</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">python manage.py collectstatic</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Run tests</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">python manage.py test</span>
</code></pre></div></div>

<p>Assuming all those previous steps succeed, the files are uploaded for the next job. The virtual environment is <strong>not</strong> uploaded since it is not compatible with the runtime OS. A nice side-effect of uploading the files at the end of the job is that you can download the files from the <strong>Actions</strong> tab to debug or inspect the contents if a deployment fails.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload artifact for deployment jobs</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/upload-artifact@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">python-app</span>
    <span class="na">path</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">. </span>
      <span class="s">!venv/</span>
</code></pre></div></div>

<p>The second job begins by downloading the files we uploaded in the previous job, then logs into the Azure CLI using a Service Principal that you set as a secret earlier.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/download-artifact@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">python-app</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">.</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Log in to Azure CLI</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">azure/login@v1</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">creds</span><span class="pi">:</span> <span class="s">${{ secrets.AZURE_SERVICE_PRINCIPAL }}</span>
</code></pre></div></div>

<p>Once the Azure CLI is authenticated, the job sets the <code class="language-plaintext highlighter-rouge">SCM_DO_BUILD_DURING_DEPLOYMENT</code> setting mentioned earlier. It also sets app settings to disable static collection (since that was done in the previous job), to run migrations on the database, and to set the Django environment to “production”. The <code class="language-plaintext highlighter-rouge">POST_BUILD_COMMAND</code> is a hook where you can execute commands following the runtime build. In this case, we’re running <code class="language-plaintext highlighter-rouge">manage.py makemigrations &amp;&amp; python migrate</code>. You <em>could</em> apply database migrations as part of the CI workflow, but you would need to set the connection string as a secret, and if you have networking rules securing your database you will need to make the database accessible from the CI pipeline. In this case, migration will be applied from the Django app on App Service, so this assumes you have <a href="https://docs.microsoft.com/azure/app-service/tutorial-python-postgresql-app?tabs=bash%2Cclone#42-configure-environment-variables-to-connect-the-database">set the database credentials on the web app</a>.</p>

<p>Finally, the job deploys the code using the <a href="https://github.com/azure/webapps-deploy/"><code class="language-plaintext highlighter-rouge">webapps-deploy</code> action</a>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Disable static collection and set migration command on App Service</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">Azure/appservice-settings@v1</span>
  <span class="na">with</span><span class="pi">:</span>  
    <span class="na">app-name</span><span class="pi">:</span> <span class="s">${{ env.WEBAPP_NAME }}</span>
    <span class="na">app-settings-json</span><span class="pi">:</span> <span class="s1">'</span><span class="s">[{</span><span class="nv"> </span><span class="s">"name":</span><span class="nv"> </span><span class="s">"DISABLE_COLLECTSTATIC",</span><span class="nv"> </span><span class="s">"value":</span><span class="nv"> </span><span class="s">"true"</span><span class="nv"> </span><span class="s">},</span><span class="nv"> </span><span class="s">{</span><span class="nv"> </span><span class="s">"name":</span><span class="nv"> </span><span class="s">"POST_BUILD_COMMAND",</span><span class="nv">  </span><span class="s">"value":</span><span class="nv"> </span><span class="s">"python</span><span class="nv"> </span><span class="s">manage.py</span><span class="nv"> </span><span class="s">makemigrations</span><span class="nv"> </span><span class="s">&amp;&amp;</span><span class="nv"> </span><span class="s">python</span><span class="nv"> </span><span class="s">manage.py</span><span class="nv"> </span><span class="s">migrate"</span><span class="nv"> </span><span class="s">},</span><span class="nv"> </span><span class="s">{</span><span class="nv"> </span><span class="s">"name":</span><span class="nv"> </span><span class="s">"SCM_DO_BUILD_DURING_DEPLOYMENT",</span><span class="nv"> </span><span class="s">"value":</span><span class="nv"> </span><span class="s">"true"</span><span class="nv"> </span><span class="s">},</span><span class="nv"> </span><span class="s">{</span><span class="nv"> </span><span class="s">"name":</span><span class="nv"> </span><span class="s">"DJANGO_ENV",</span><span class="nv"> </span><span class="s">"value":</span><span class="nv"> </span><span class="s">"production"}]'</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to App Service</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">azure/webapps-deploy@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">app-name</span><span class="pi">:</span> <span class="s">${{ env.WEBAPP_NAME}}</span>
</code></pre></div></div>

<blockquote>
  <p>By default, the <code class="language-plaintext highlighter-rouge">appservice-settings</code> action will mask the inputs and obfuscate any occurences of those strings in logs. Set <a href="https://github.com/Azure/appservice-settings/blob/master/action.yml#L20-L23"><code class="language-plaintext highlighter-rouge">mask-inputs: false</code></a> to disable this.</p>
</blockquote>

<h3 id="flask-and-vuejs">Flask and Vue.js</h3>

<p>See the <a href="https://github.com/Azure-Samples/flask-vuejs-webapp/blob/main/.github/workflows/build_and_deploy.yaml"><strong>example workflow for building and deploying a Flask app with Vue.js</strong></a>. Fork this repository and <a href="https://docs.github.com/en/free-pro-team@latest/actions/reference/encrypted-secrets">create a secret</a> with the Service Principal. Name the secret <code class="language-plaintext highlighter-rouge">AZURE_SERVICE_PRINCIPAL</code>. You also need to replace the placeholder value for the <code class="language-plaintext highlighter-rouge">RESOURCE_GROUP</code> environment variable at the top of the workflow file.</p>

<p>This workflow begins similarly to the Django example by setting the Python version, creating a virtual environment, and installing the Python packages. Unique to this example, it also sets Node.js to the desired version since the job will need to install the Vue project’s dependencies and build it.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/checkout@v2</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Python</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-python@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">python-version</span><span class="pi">:</span> <span class="m">3.6</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Set up Node.js</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/setup-node@v1</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">node-version</span><span class="pi">:</span> <span class="m">12</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install and build Vue.js project</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">npm install</span>
    <span class="s">npm run build</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Create and start virtual environment</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">python3 -m venv venv</span>
    <span class="s">source venv/bin/activate</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Install dependencies</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">pip install -r requirements.txt</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">test with PyTest</span>
  <span class="na">run</span><span class="pi">:</span> <span class="s">pytest --cov=app --cov-report=xml</span>
</code></pre></div></div>

<p>Once the Flask and Vue.js apps are built and tested the files are uploaded for the second job… except for the <code class="language-plaintext highlighter-rouge">node_modules/</code> and <code class="language-plaintext highlighter-rouge">venv/</code> directories. We want to exclude these directories and allow Oryx to install the dependencies on the runtime image like in the Django example.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Upload artifact for deployment jobs</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/upload-artifact@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">python-app</span>
    <span class="na">path</span><span class="pi">:</span> <span class="pi">|</span>
      <span class="s">. </span>
      <span class="s">!node_modules/</span>
      <span class="s">!venv/</span>
</code></pre></div></div>

<p>The second job downloads the artifact, logs into the Azure CLI, and sets the <code class="language-plaintext highlighter-rouge">SCM_DO_BUILD_DURING_DEPLOYMENT</code> flag and <code class="language-plaintext highlighter-rouge">FLASK_ENV</code> to “production”. Unlike the Django example, the workflow sets the “startup-file” command to <code class="language-plaintext highlighter-rouge">gunicorn --bind=0.0.0.0 --timeout 600 app:app</code>. (<a href="https://docs.gunicorn.org/en/stable/index.html">Gunicorn</a> is a WSGI HTTP Server commonly used for Python applications. Learn more about <a href="https://docs.microsoft.com/azure/app-service/configure-language-python#customize-startup-command">custom startup commands on App Service</a>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">uses</span><span class="pi">:</span> <span class="s">actions/download-artifact@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">python-app</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">.</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Log in to Azure CLI</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">azure/login@v1</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">creds</span><span class="pi">:</span> <span class="s">${{ secrets.AZURE_SERVICE_PRINCIPAL }}</span>

<span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Configure deployment and runtime settings on the webapp</span>
  <span class="na">run</span><span class="pi">:</span> <span class="pi">|</span>
    <span class="s">az configure --defaults ${{ env.RESOURCE_GROUP }}</span>
    <span class="s">az webapp config appsettings --name ${{ env.WEBAPP_NAME }} --settings \</span>
        <span class="s">SCM_DO_BUILD_DURING_DEPLOYMENT=true \</span>
        <span class="s">FLASK_ENV=production</span>

    <span class="s">az webapp config set --name ${{ env.WEBAPP_NAME }} \</span>
        <span class="s">--startup-file "gunicorn --bind=0.0.0.0 --timeout 600 app:app"</span>
</code></pre></div></div>

<p>Finally, the application is deployed with the <a href="https://github.com/azure/webapps-deploy/"><code class="language-plaintext highlighter-rouge">webapps-deploy</code></a> action.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">Deploy to App Service</span>
  <span class="na">uses</span><span class="pi">:</span> <span class="s">azure/webapps-deploy@v2</span>
  <span class="na">with</span><span class="pi">:</span>
    <span class="na">app-name</span><span class="pi">:</span> <span class="s">${{ env.WEBAPP_NAME}}</span>
</code></pre></div></div>


        
      </section>

      <footer class="page__meta">
          <p class="page__date"><strong><a href="https://docs.microsoft.com/answers/topics/azure-webapps.html">Post questions</a> | <a href="https://feedback.azure.com/forums/169385-web-apps">Provide product feedback</a></strong></p>
        
        


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-12-11T00:00:00+00:00">December 11, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Using+GitHub+Actions+for+Python+Applications%20https%3A%2F%2Fazure.github.io%2FAppService%2F2020%2F12%2F11%2Fcicd-for-python-apps.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fazure.github.io%2FAppService%2F2020%2F12%2F11%2Fcicd-for-python-apps.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fazure.github.io%2FAppService%2F2020%2F12%2F11%2Fcicd-for-python-apps.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/AppService/2020/12/09/AzMon-AppServiceAntivirusScanAuditLogs.html" class="pagination--pager" title="New App Service Anti-virus Logs in Public Preview
">Previous</a>
    
    
      <a href="/AppService/2021/01/04/deploying-to-network-secured-sites.html" class="pagination--pager" title="Deploying to Network-secured sites
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/AppService/media/pages/new_app_service_logo_64.svg"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/AppService/2025/11/04/app-service-agent-framework-part-3.html" rel="permalink">Part 3: Client-Side Multi-Agent Orchestration on Azure App Service with Microsoft Agent Framework
</a>
      
    </h2>
    
      <p class="page__meta">
        
          <i class="far fa-clock" aria-hidden="true"></i> 




  12 minute read

        
        
          • By Jordan Selig
        
        • November 4, 2025
      </p>
    
    <p class="archive__item-excerpt" itemprop="description">In Part 2 of this series, I showed you how to build sophisticated multi-agent systems on Azure App Service using Azure AI Foundry Agents—server-side managed ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/AppService/media/pages/new_app_service_logo_64.svg"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/AppService/2025/10/31/app-service-agent-framework-part-2.html" rel="permalink">Part 2: Build Long-Running AI Agents on Azure App Service with Microsoft Agent Framework
</a>
      
    </h2>
    
      <p class="page__meta">
        
          <i class="far fa-clock" aria-hidden="true"></i> 




  9 minute read

        
        
          • By Jordan Selig
        
        • October 31, 2025
      </p>
    
    <p class="archive__item-excerpt" itemprop="description">Last week, I shared how to build long-running AI agents on Azure App Service with Microsoft Agent Framework. If you haven’t seen that post yet, I would recom...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/AppService/media/pages/new_app_service_logo_64.svg"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/AppService/2025/10/29/node24-available.html" rel="permalink">Node.js 24 is now available on Azure App Service for Linux
</a>
      
    </h2>
    
      <p class="page__meta">
        
          <i class="far fa-clock" aria-hidden="true"></i> 




  1 minute read

        
        
          • By Tulika Chaudharie
        
        • October 29, 2025
      </p>
    
    <p class="archive__item-excerpt" itemprop="description">Node.js 24 LTS is live on Azure App Service for Linux. You can create a new Node 24 app through the Azure portal, automate it with the Azure CLI, or roll it ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src=
          
            "/AppService/media/pages/new_app_service_logo_64.svg"
          
          alt="">
      </div>
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/AppService/2025/10/29/VSTS-tasks-for-sidecars.html" rel="permalink">Azure Pipeline samples: add sidecars to Azure App Service for Linux
</a>
      
    </h2>
    
      <p class="page__meta">
        
          <i class="far fa-clock" aria-hidden="true"></i> 




  3 minute read

        
        
          • By Tulika Chaudharie
        
        • October 29, 2025
      </p>
    
    <p class="archive__item-excerpt" itemprop="description">Sidecars on Azure App Service let you attach extra containers — logging, telemetry, lightweight APIs, caches, AI inference helpers — alongside your main app,...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form onsubmit="return googleCustomSearchExecute();" id="cse-search-box-form-id">
    <label class="sr-only" for="cse-search-input-box-id">
      Enter your search term...
    </label>
    <input type="search" id="cse-search-input-box-id" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results">
    <gcse:searchresults-only></gcse:searchresults-only>
  </div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  
    <a class="page-microsoft" href="https://www.microsoft.com"><img src="/AppService/media/pages/Microsoft_logo.svg" alt=""></a>
  
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
          <li><a href="https://twitter.com/AzAppService" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
        
      
        
          <li><a href="https://github.com/Azure/AppService" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    <li><a href="/AppService/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2025 Azure App Service. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/AppService/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>


<script>
  (function () {
    var cx = '015057007851139702326:ob8gaepprli';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();

  function googleCustomSearchExecute() {
    var input = document.getElementById('cse-search-input-box-id');
    var element = google.search.cse.element.getElement('searchresults-only0');
    if (input.value == '') {
      element.clearAllResults();
    } else {
      element.execute(input.value);
    }
    return false;
  }

  
    $(document).ready(function () {
      $('input#cse-search-input-box-id').on('keyup', function () {
        googleCustomSearchExecute();
      });
    });
  
</script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-112478220-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>









  </body>
</html>
